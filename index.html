<!DOCTYPE html>
<html lang="ru" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Glass Watermark</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Liquid Watermark">
    <link rel="apple-touch-icon" href="logo.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; }
        .drop-zone { 
            border: 2px dashed #cbd5e1;
            transition: all 0.3s;
        }
        .drop-zone.active {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        canvas { 
            max-width: 100%;
            height: auto;
            cursor: move;
            touch-action: none;
        }
        #canvas-container {
            position: relative;
            display: inline-block;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen p-4 md:p-8 transition-colors duration-200">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-black text-gray-900 dark:text-white mb-8 text-center">Liquid Glass Watermark</h1>
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- Controls Panel -->
            <div class="lg:col-span-1 space-y-6">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 transition-colors duration-200">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold text-gray-800 dark:text-white">Настройки</h2>
                        <div class="flex items-center space-x-2">
                            <button id="colorToggle" class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors" title="Переключить цвет текста">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path>
                                </svg>
                            </button>
                            <button id="themeToggle" class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">
                                <!-- Sun Icon -->
                                <svg id="sunIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                                <!-- Moon Icon -->
                                <svg id="moonIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                            </button>
                        </div>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">Текст</label>
                            <input type="text" id="textInput" value="RENGEV" 
                                   class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-colors">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                                Размер: <span id="scaleValue">1.0</span>x
                            </label>
                            <input type="range" id="scaleSlider" min="0.3" max="3" step="0.1" value="1" 
                                   class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                                Прозрачность: <span id="opacityValue">100</span>%
                            </label>
                            <input type="range" id="opacitySlider" min="0" max="100" step="5" value="100" 
                                   class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <button id="downloadBtn" 
                                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled>
                            Скачать изображение
                        </button>
                        
                        <button id="resetBtn" 
                                class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled>
                            Сбросить
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Canvas Area -->
            <div class="lg:col-span-2">
                <div id="uploadZone" class="drop-zone bg-white dark:bg-gray-800 rounded-xl shadow-lg p-12 text-center cursor-pointer transition-colors duration-200">
                    <svg class="mx-auto h-16 w-16 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    <h3 class="text-xl font-bold text-gray-700 dark:text-gray-200 mb-2">Загрузите изображение</h3>
                    <p class="text-gray-500 dark:text-gray-400 mb-4">или перетащите файл сюда</p>
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition">
                        Выбрать файл
                    </button>
                    <input type="file" id="fileInput" accept="image/*" class="hidden">
                </div>
                
                <div id="canvasWrapper" class="hidden mt-6">
                    <div id="canvas-container" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4 inline-block transition-colors duration-200">
                        <canvas id="canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State
        let state = {
            image: null,
            watermarkX: 0,
            watermarkY: 0,
            text: 'RENGEV',
            scale: 1,
            opacity: 1,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            offsetX: 0,
            offsetY: 0,
            isDarkText: false
        };

        let renderRequestId = null;

        // Elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const textInput = document.getElementById('textInput');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValue = document.getElementById('scaleValue');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const colorToggle = document.getElementById('colorToggle');

        // Draw watermark function
        function drawWatermark(ctx, x, y, scale, opacity) {
            const text = state.text;
            const baseFontSize = 48;
            const fontSize = baseFontSize * scale;
            
            ctx.font = `900 ${fontSize}px 'Inter'`;
            
            // Measure text with letter spacing
            const letterSpacing = fontSize * 0.05;
            let totalWidth = 0;
            for (let i = 0; i < text.length; i++) {
                totalWidth += ctx.measureText(text[i]).width;
                if (i < text.length - 1) totalWidth += letterSpacing;
            }
            
            // Dimensions
            const paddingX = 50 * scale;
            const paddingY = 25 * scale;
            const capsuleWidth = totalWidth + paddingX * 2;
            const capsuleHeight = fontSize + paddingY * 2;
            const borderRadius = 100 * scale;
            
            // --- 1. SHADOW (External) ---
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
            ctx.shadowBlur = 25 * scale;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 12 * scale;
            
            ctx.fillStyle = 'rgba(0,0,0,0)'; 
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.fill();
            ctx.restore();

            // --- 2. REFRACTION / MAGNIFICATION ---
            ctx.save();
            ctx.globalAlpha = opacity;
            
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.clip(); 

            if (state.image) {
                // To simulate refraction: draw a portion of the original image that is 
                // slightly smaller than the watermark area, scaled up.
                // This creates a "magnifying lens" effect.
                
                const zoomFactor = 0.05; // Reduced from 0.15 to avoid ghosting
                
                // Source rectangle (what we capture from underlying image)
                // We shrink the capture area relative to center
                const sx = x + (capsuleWidth * zoomFactor * 0.5);
                const sy = y + (capsuleHeight * zoomFactor * 0.5);
                const sw = capsuleWidth * (1 - zoomFactor);
                const sh = capsuleHeight * (1 - zoomFactor);

                // Apply mild blur to simulate thick glass, but keep it clearer than before
                // Increased contrast slightly for pop
                ctx.filter = `blur(${3 * scale}px) saturate(1.1) contrast(1.05)`;
                
                // Draw clipped and zoomed
                // Destination is full watermark size (x, y, capsuleWidth, capsuleHeight)
                ctx.drawImage(state.image, sx, sy, sw, sh, x, y, capsuleWidth, capsuleHeight);
            }
            ctx.restore();

            // --- 3. GLASS SURFACE (Gloss) ---
            ctx.save();
            ctx.globalAlpha = opacity;
            
            // Ultra-clear glass: very faint gradients
            const gradient = ctx.createLinearGradient(x, y, x + capsuleWidth, y + capsuleHeight);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');    // Almost invisible highlight top-left
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.00)'); // Totally clear middle
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.02)');   // Faint bottom-right
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.fill();
            
            // --- 4. RIM LIGHTING & HIGHLIGHTS ---
            // Balanced, symmetrical border for uniform look
            ctx.lineWidth = 0.8 * scale;
            
            // Create a symmetrical gradient for the border
            const borderGradient = ctx.createLinearGradient(x, y, x + capsuleWidth, y);
            borderGradient.addColorStop(0, 'rgba(255, 255, 255, 0.45)');   // Left highlight
            borderGradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.15)'); // Fade in
            borderGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)'); // Dim middle
            borderGradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.15)'); // Fade out
            borderGradient.addColorStop(1, 'rgba(255, 255, 255, 0.45)');   // Right highlight
            
            ctx.strokeStyle = borderGradient;
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.stroke();

            // Add an additional subtle inner glow for more depth and uniformity
            ctx.save();
            ctx.lineWidth = 1.2 * scale;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.beginPath();
            ctx.roundRect(x + 1 * scale, y + 1 * scale, capsuleWidth - 2 * scale, capsuleHeight - 2 * scale, borderRadius);
            ctx.stroke();
            ctx.restore();
            
            ctx.restore();

            // --- 5. TEXT ---
            ctx.save();
            ctx.globalAlpha = opacity;
            
            // User requested styles:
            // color: rgba(255, 255, 255, 0.5);
            // text-shadow: 0px 4px 14px rgba(0, 0, 0, 0.42);
            
            ctx.shadowColor = state.isDarkText ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.42)';
            ctx.shadowBlur = 14 * scale;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4 * scale;
            
            ctx.fillStyle = state.isDarkText ? 'rgba(0, 0, 0, 0.65)' : 'rgba(255, 255, 255, 0.5)';
            ctx.textBaseline = 'middle';
            
            let currentX = x + paddingX;
            const textY = y + capsuleHeight / 2;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const charWidth = ctx.measureText(char).width;
                ctx.fillText(char, currentX, textY);
                currentX += charWidth + letterSpacing;
            }
            ctx.restore();
        }

        // Render canvas loop
        function requestRender() {
            if (!renderRequestId) {
                renderRequestId = requestAnimationFrame(() => {
                    render();
                    renderRequestId = null;
                });
            }
        }

        function render() {
            if (!state.image) return;
            
            canvas.width = state.image.width;
            canvas.height = state.image.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(state.image, 0, 0);
            
            drawWatermark(ctx, state.watermarkX, state.watermarkY, state.scale, state.opacity);
        }

        // Load image
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    state.watermarkX = img.width * 0.05;
                    state.watermarkY = img.height * 0.05;
                    
                    uploadZone.classList.add('hidden');
                    canvasWrapper.classList.remove('hidden');
                    downloadBtn.disabled = false;
                    resetBtn.disabled = false;
                    
                    requestRender();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Event listeners
        uploadZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadImage(e.target.files[0]);
        });

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('active');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('active');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('active');
            if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
        });

        textInput.addEventListener('input', (e) => {
            state.text = e.target.value || 'RENGEV';
            requestRender();
        });

        scaleSlider.addEventListener('input', (e) => {
            state.scale = parseFloat(e.target.value);
            scaleValue.textContent = state.scale.toFixed(1);
            requestRender();
        });

        opacitySlider.addEventListener('input', (e) => {
            state.opacity = parseInt(e.target.value) / 100;
            opacityValue.textContent = e.target.value;
            requestRender();
        });

        // Drag and drop watermark
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function isInsideWatermark(x, y) {
            const text = state.text;
            const fontSize = 48 * state.scale;
            ctx.font = `900 ${fontSize}px 'Inter'`;
            
            const letterSpacing = fontSize * 0.09;
            let totalWidth = 0;
            for (let i = 0; i < text.length; i++) {
                totalWidth += ctx.measureText(text[i]).width;
                if (i < text.length - 1) totalWidth += letterSpacing;
            }
            
            const paddingX = 50 * state.scale;
            const paddingY = 25 * state.scale;
            const capsuleWidth = totalWidth + paddingX * 2;
            const capsuleHeight = fontSize + paddingY * 2;
            
            return x >= state.watermarkX && x <= state.watermarkX + capsuleWidth &&
                   y >= state.watermarkY && y <= state.watermarkY + capsuleHeight;
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getEventPos(e);
            if (isInsideWatermark(pos.x, pos.y)) {
                state.isDragging = true;
                state.offsetX = pos.x - state.watermarkX;
                state.offsetY = pos.y - state.watermarkY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const pos = getEventPos(e);
            if (isInsideWatermark(pos.x, pos.y)) {
                state.isDragging = true;
                state.offsetX = pos.x - state.watermarkX;
                state.offsetY = pos.y - state.watermarkY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (state.isDragging) {
                const pos = getEventPos(e);
                state.watermarkX = pos.x - state.offsetX;
                state.watermarkY = pos.y - state.offsetY;
                requestRender();
            } else {
                const pos = getEventPos(e);
                canvas.style.cursor = isInsideWatermark(pos.x, pos.y) ? 'grab' : 'move';
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (state.isDragging) {
                const pos = getEventPos(e);
                state.watermarkX = pos.x - state.offsetX;
                state.watermarkY = pos.y - state.offsetY;
                requestRender();
            }
        });

        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            canvas.style.cursor = 'move';
        });

        canvas.addEventListener('touchend', () => {
            state.isDragging = false;
        });

        document.addEventListener('mouseup', () => {
            state.isDragging = false;
            canvas.style.cursor = 'move';
        });

        // Download
        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `watermarked-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
        });

        // Reset
        resetBtn.addEventListener('click', () => {
            state = {
                image: null,
                watermarkX: 0,
                watermarkY: 0,
                text: 'RENGEV',
                scale: 1,
                opacity: 1,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                offsetX: 0,
                offsetY: 0,
                isDarkText: false
            };
            
            textInput.value = 'RENGEV';
            scaleSlider.value = 1;
            scaleValue.textContent = '1.0';
            opacitySlider.value = 100;
            opacityValue.textContent = '100';
            
            uploadZone.classList.remove('hidden');
            canvasWrapper.classList.add('hidden');
            downloadBtn.disabled = true;
            resetBtn.disabled = true;
            fileInput.value = '';
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        const html = document.documentElement;

        function updateTheme(isDark) {
            if (isDark) {
                html.classList.add('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            } else {
                html.classList.remove('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            }
        }

        themeToggle.addEventListener('click', () => {
            const isDark = !html.classList.contains('dark');
            updateTheme(isDark);
        });

        colorToggle.addEventListener('click', () => {
            state.isDarkText = !state.isDarkText;
            requestRender();
        });
    </script>
</body>
</html>