<!DOCTYPE html>
<html lang="ru" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Glass Watermark</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Liquid Watermark">
    <link rel="apple-touch-icon" href="logo.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; }
        .drop-zone { 
            border: 2px dashed #cbd5e1;
            transition: all 0.3s;
        }
        .drop-zone.active {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        canvas { 
            max-width: 100%;
            height: auto;
            cursor: move;
            touch-action: none;
        }
        #canvas-container {
            position: relative;
            display: inline-block;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen p-4 md:p-8 transition-colors duration-200">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-black text-gray-900 dark:text-white mb-8 text-center">Liquid Glass Watermark</h1>
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- Controls Panel -->
            <div class="lg:col-span-1 space-y-6">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 transition-colors duration-200">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold text-gray-800 dark:text-white">Настройки</h2>
                        <div class="flex items-center space-x-2">
                            <button id="colorToggle" class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors" title="Переключить цвет текста">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path>
                                </svg>
                            </button>
                            <button id="themeToggle" class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">
                                <!-- Sun Icon -->
                                <svg id="sunIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                                <!-- Moon Icon -->
                                <svg id="moonIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                            </button>
                        </div>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">Текст</label>
                            <input type="text" id="textInput" value="RENGEV" 
                                   class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-colors">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                                Размер: <span id="scaleValue">1.0</span>x
                            </label>
                            <input type="range" id="scaleSlider" min="0.3" max="3" step="0.1" value="1" 
                                   class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                                Прозрачность: <span id="opacityValue">100</span>%
                            </label>
                            <input type="range" id="opacitySlider" min="0" max="100" step="5" value="100" 
                                   class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <button id="downloadBtn" 
                                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled>
                            Скачать изображение
                        </button>
                        
                        <button id="resetBtn" 
                                class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled>
                            Сбросить
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Canvas Area -->
            <div class="lg:col-span-2">
                <div id="uploadZone" class="drop-zone bg-white dark:bg-gray-800 rounded-xl shadow-lg p-12 text-center cursor-pointer transition-colors duration-200">
                    <svg class="mx-auto h-16 w-16 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    <h3 class="text-xl font-bold text-gray-700 dark:text-gray-200 mb-2">Загрузите изображение</h3>
                    <p class="text-gray-500 dark:text-gray-400 mb-4">или перетащите файл сюда</p>
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition">
                        Выбрать файл
                    </button>
                    <input type="file" id="fileInput" accept="image/*" class="hidden">
                </div>
                
                <div id="canvasWrapper" class="hidden mt-6">
                    <div id="canvas-container" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4 inline-block transition-colors duration-200">
                        <canvas id="canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State
        let state = {
            image: null,
            watermarkX: 0,
            watermarkY: 0,
            text: 'RENGEV',
            scale: 1,
            opacity: 1,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            offsetX: 0,
            offsetY: 0,
            isDarkText: false
        };

        let renderRequestId = null;

        // Elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const textInput = document.getElementById('textInput');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValue = document.getElementById('scaleValue');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const colorToggle = document.getElementById('colorToggle');

        // Helper: Sample colors from image along the capsule border
        function sampleBorderColors(image, x, y, width, height, radius, numSamples = 32) {
            // Create temporary canvas for sampling
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = image.width;
            tempCanvas.height = image.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(image, 0, 0);
            
            const colors = [];
            const offset = 8; // Sample slightly outside the border
            
            // Sample around the perimeter of the rounded rectangle
            for (let i = 0; i < numSamples; i++) {
                const t = i / numSamples;
                let sampleX, sampleY;
                
                // Approximate rounded rect perimeter sampling
                const perimeter = 2 * (width + height - 4 * radius) + 2 * Math.PI * radius;
                const pos = t * perimeter;
                
                // Top edge
                const topLength = width - 2 * radius;
                // Right edge
                const rightLength = height - 2 * radius;
                // Bottom edge
                const bottomLength = width - 2 * radius;
                // Left edge
                const leftLength = height - 2 * radius;
                // Corner arcs
                const cornerLength = Math.PI * radius / 2;
                
                let accumulated = 0;
                
                if (pos < topLength) {
                    // Top edge
                    sampleX = x + radius + pos;
                    sampleY = y - offset;
                } else if (pos < topLength + cornerLength) {
                    // Top-right corner
                    const angle = -Math.PI / 2 + (pos - topLength) / radius;
                    sampleX = x + width - radius + Math.cos(angle) * (radius + offset);
                    sampleY = y + radius + Math.sin(angle) * (radius + offset);
                } else if (pos < topLength + cornerLength + rightLength) {
                    // Right edge
                    sampleX = x + width + offset;
                    sampleY = y + radius + (pos - topLength - cornerLength);
                } else if (pos < topLength + 2 * cornerLength + rightLength) {
                    // Bottom-right corner
                    const angle = 0 + (pos - topLength - cornerLength - rightLength) / radius;
                    sampleX = x + width - radius + Math.cos(angle) * (radius + offset);
                    sampleY = y + height - radius + Math.sin(angle) * (radius + offset);
                } else if (pos < topLength + 2 * cornerLength + rightLength + bottomLength) {
                    // Bottom edge
                    sampleX = x + width - radius - (pos - topLength - 2 * cornerLength - rightLength);
                    sampleY = y + height + offset;
                } else if (pos < topLength + 3 * cornerLength + rightLength + bottomLength) {
                    // Bottom-left corner
                    const angle = Math.PI / 2 + (pos - topLength - 2 * cornerLength - rightLength - bottomLength) / radius;
                    sampleX = x + radius + Math.cos(angle) * (radius + offset);
                    sampleY = y + height - radius + Math.sin(angle) * (radius + offset);
                } else if (pos < topLength + 3 * cornerLength + rightLength + bottomLength + leftLength) {
                    // Left edge
                    sampleX = x - offset;
                    sampleY = y + height - radius - (pos - topLength - 3 * cornerLength - rightLength - bottomLength);
                } else {
                    // Top-left corner
                    const angle = Math.PI + (pos - topLength - 3 * cornerLength - rightLength - bottomLength - leftLength) / radius;
                    sampleX = x + radius + Math.cos(angle) * (radius + offset);
                    sampleY = y + radius + Math.sin(angle) * (radius + offset);
                }
                
                // Clamp to image bounds
                sampleX = Math.max(0, Math.min(image.width - 1, Math.floor(sampleX)));
                sampleY = Math.max(0, Math.min(image.height - 1, Math.floor(sampleY)));
                
                try {
                    const pixel = tempCtx.getImageData(sampleX, sampleY, 1, 1).data;
                    colors.push({
                        r: pixel[0],
                        g: pixel[1],
                        b: pixel[2],
                        t: t
                    });
                } catch (e) {
                    colors.push({ r: 255, g: 255, b: 255, t: t });
                }
            }
            
            return colors;
        }

        // Draw watermark function
        function drawWatermark(ctx, x, y, scale, opacity) {
            const text = state.text;
            const baseFontSize = 48;
            const fontSize = baseFontSize * scale;
            
            ctx.font = `900 ${fontSize}px 'Inter'`;
            
            // Measure text with letter spacing
            const letterSpacing = fontSize * 0.05;
            let totalWidth = 0;
            for (let i = 0; i < text.length; i++) {
                totalWidth += ctx.measureText(text[i]).width;
                if (i < text.length - 1) totalWidth += letterSpacing;
            }
            
            // Dimensions
            const paddingX = 50 * scale;
            const paddingY = 25 * scale;
            const capsuleWidth = totalWidth + paddingX * 2;
            const capsuleHeight = fontSize + paddingY * 2;
            const borderRadius = 100 * scale;
            
            // --- 1. SHADOW (External) - Multi-layer for depth ---
            // Layer 1: Soft ambient shadow
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 30 * scale;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 15 * scale;
            
            ctx.fillStyle = 'rgba(0,0,0,0)'; 
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.fill();
            ctx.restore();
            
            // Layer 2: Contact shadow (sharper, closer)
            ctx.save();
            ctx.globalAlpha = opacity * 0.6;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.35)';
            ctx.shadowBlur = 8 * scale;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4 * scale;
            
            ctx.fillStyle = 'rgba(0,0,0,0)'; 
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.fill();
            ctx.restore();

            // --- 2. REFRACTION / MAGNIFICATION with Chromatic Aberration ---
            ctx.save();
            ctx.globalAlpha = opacity;
            
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.clip(); 

            if (state.image) {
                const zoomFactor = 0.06;
                
                const sx = x + (capsuleWidth * zoomFactor * 0.5);
                const sy = y + (capsuleHeight * zoomFactor * 0.5);
                const sw = capsuleWidth * (1 - zoomFactor);
                const sh = capsuleHeight * (1 - zoomFactor);

                // Main refracted image with blur
                ctx.filter = `blur(${2.5 * scale}px) saturate(1.15) contrast(1.08)`;
                ctx.drawImage(state.image, sx, sy, sw, sh, x, y, capsuleWidth, capsuleHeight);
                
                // Subtle chromatic aberration at edges
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.03;
                
                // Red channel shift
                ctx.filter = 'none';
                ctx.drawImage(state.image, sx - 1.5 * scale, sy, sw, sh, x, y, capsuleWidth, capsuleHeight);
                
                // Blue channel shift
                ctx.drawImage(state.image, sx + 1.5 * scale, sy, sw, sh, x, y, capsuleWidth, capsuleHeight);
                
                ctx.globalCompositeOperation = 'source-over';
                ctx.filter = 'none';
            }
            ctx.restore();

            // --- 3. INNER SHADOW (Glass thickness/depth) ---
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.clip();
            
            // Draw shadow inward by stroking a larger path
            ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
            ctx.shadowBlur = 15 * scale;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 5 * scale;
            
            ctx.lineWidth = 20 * scale;
            ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
            ctx.beginPath();
            ctx.roundRect(x - 10 * scale, y - 10 * scale, capsuleWidth + 20 * scale, capsuleHeight + 20 * scale, borderRadius + 10 * scale);
            ctx.stroke();
            ctx.restore();

            // --- 4. PURE GLASS SURFACE (minimal, clean) ---
            // No internal highlights - just the refraction effect
            // The 3D depth comes from the rim lighting and inner shadow only

            // --- 5. ADAPTIVE 3D RIM LIGHTING ---
            // Sample colors from the surrounding image
            let borderColors = [];
            if (state.image) {
                borderColors = sampleBorderColors(state.image, x, y, capsuleWidth, capsuleHeight, borderRadius, 48);
            }
            
            ctx.save();
            ctx.globalAlpha = opacity;
            
            // Layer 1: Outer glow with sampled colors (the "funnel" effect)
            if (borderColors.length > 0) {
                ctx.lineWidth = 6 * scale;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Create gradient from sampled colors with brightness boost
                const adaptiveGradient = ctx.createConicGradient(
                    Math.PI / 2,
                    x + capsuleWidth / 2,
                    y + capsuleHeight / 2
                );
                
                borderColors.forEach((color, i) => {
                    // Boost brightness for rim lighting effect
                    const boost = 1.4;
                    const r = Math.min(255, color.r * boost);
                    const g = Math.min(255, color.g * boost);
                    const b = Math.min(255, color.b * boost);
                    adaptiveGradient.addColorStop(color.t, `rgba(${r}, ${g}, ${b}, 0.35)`);
                });
                
                ctx.filter = `blur(${3 * scale}px)`;
                ctx.strokeStyle = adaptiveGradient;
                ctx.beginPath();
                ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
                ctx.stroke();
                ctx.filter = 'none';
            }
            
            // Layer 2: Main rim highlight with vertical gradient (top-lit 3D effect)
            ctx.lineWidth = 2.5 * scale;
            const rimGradient = ctx.createLinearGradient(x, y, x, y + capsuleHeight);
            rimGradient.addColorStop(0, 'rgba(255, 255, 255, 0.75)');
            rimGradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.35)');
            rimGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.1)');
            rimGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.08)');
            rimGradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.2)');
            rimGradient.addColorStop(1, 'rgba(255, 255, 255, 0.5)');
            
            ctx.strokeStyle = rimGradient;
            ctx.beginPath();
            ctx.roundRect(x, y, capsuleWidth, capsuleHeight, borderRadius);
            ctx.stroke();
            
            // Layer 3: Subtle outer dark edge (containment)
            ctx.lineWidth = 1 * scale;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.beginPath();
            ctx.roundRect(x - 0.5 * scale, y - 0.5 * scale, capsuleWidth + 1 * scale, capsuleHeight + 1 * scale, borderRadius + 0.5 * scale);
            ctx.stroke();
            
            // Layer 4: Inner subtle accent line (very thin)
            ctx.lineWidth = 0.8 * scale;
            const innerGlowGradient = ctx.createLinearGradient(x, y, x, y + capsuleHeight);
            innerGlowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            innerGlowGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.08)');
            innerGlowGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.05)');
            innerGlowGradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');
            
            ctx.strokeStyle = innerGlowGradient;
            ctx.beginPath();
            ctx.roundRect(x + 1.5 * scale, y + 1.5 * scale, capsuleWidth - 3 * scale, capsuleHeight - 3 * scale, borderRadius - 1.5 * scale);
            ctx.stroke();
            
            ctx.restore();

            // --- 5. TEXT (brighter) ---
            ctx.save();
            ctx.globalAlpha = opacity;
            
            ctx.shadowColor = state.isDarkText ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 16 * scale;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4 * scale;
            
            ctx.fillStyle = state.isDarkText ? 'rgba(0, 0, 0, 0.75)' : 'rgba(255, 255, 255, 0.7)';
            ctx.textBaseline = 'middle';
            
            let currentX = x + paddingX;
            const textY = y + capsuleHeight / 2;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const charWidth = ctx.measureText(char).width;
                ctx.fillText(char, currentX, textY);
                currentX += charWidth + letterSpacing;
            }
            ctx.restore();
        }

        // Render canvas loop
        function requestRender() {
            if (!renderRequestId) {
                renderRequestId = requestAnimationFrame(() => {
                    render();
                    renderRequestId = null;
                });
            }
        }

        function render() {
            if (!state.image) return;
            
            canvas.width = state.image.width;
            canvas.height = state.image.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(state.image, 0, 0);
            
            drawWatermark(ctx, state.watermarkX, state.watermarkY, state.scale, state.opacity);
        }

        // Load image
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    state.watermarkX = img.width * 0.05;
                    state.watermarkY = img.height * 0.05;
                    
                    uploadZone.classList.add('hidden');
                    canvasWrapper.classList.remove('hidden');
                    downloadBtn.disabled = false;
                    resetBtn.disabled = false;
                    
                    requestRender();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Event listeners
        uploadZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadImage(e.target.files[0]);
        });

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('active');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('active');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('active');
            if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
        });

        textInput.addEventListener('input', (e) => {
            state.text = e.target.value || 'RENGEV';
            requestRender();
        });

        scaleSlider.addEventListener('input', (e) => {
            state.scale = parseFloat(e.target.value);
            scaleValue.textContent = state.scale.toFixed(1);
            requestRender();
        });

        opacitySlider.addEventListener('input', (e) => {
            state.opacity = parseInt(e.target.value) / 100;
            opacityValue.textContent = e.target.value;
            requestRender();
        });

        // Drag and drop watermark
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function isInsideWatermark(x, y) {
            const text = state.text;
            const fontSize = 48 * state.scale;
            ctx.font = `900 ${fontSize}px 'Inter'`;
            
            const letterSpacing = fontSize * 0.09;
            let totalWidth = 0;
            for (let i = 0; i < text.length; i++) {
                totalWidth += ctx.measureText(text[i]).width;
                if (i < text.length - 1) totalWidth += letterSpacing;
            }
            
            const paddingX = 50 * state.scale;
            const paddingY = 25 * state.scale;
            const capsuleWidth = totalWidth + paddingX * 2;
            const capsuleHeight = fontSize + paddingY * 2;
            
            return x >= state.watermarkX && x <= state.watermarkX + capsuleWidth &&
                   y >= state.watermarkY && y <= state.watermarkY + capsuleHeight;
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getEventPos(e);
            if (isInsideWatermark(pos.x, pos.y)) {
                state.isDragging = true;
                state.offsetX = pos.x - state.watermarkX;
                state.offsetY = pos.y - state.watermarkY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const pos = getEventPos(e);
            if (isInsideWatermark(pos.x, pos.y)) {
                state.isDragging = true;
                state.offsetX = pos.x - state.watermarkX;
                state.offsetY = pos.y - state.watermarkY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (state.isDragging) {
                const pos = getEventPos(e);
                state.watermarkX = pos.x - state.offsetX;
                state.watermarkY = pos.y - state.offsetY;
                requestRender();
            } else {
                const pos = getEventPos(e);
                canvas.style.cursor = isInsideWatermark(pos.x, pos.y) ? 'grab' : 'move';
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (state.isDragging) {
                const pos = getEventPos(e);
                state.watermarkX = pos.x - state.offsetX;
                state.watermarkY = pos.y - state.offsetY;
                requestRender();
            }
        });

        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            canvas.style.cursor = 'move';
        });

        canvas.addEventListener('touchend', () => {
            state.isDragging = false;
        });

        document.addEventListener('mouseup', () => {
            state.isDragging = false;
            canvas.style.cursor = 'move';
        });

        // Download
        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `watermarked-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
        });

        // Reset
        resetBtn.addEventListener('click', () => {
            state = {
                image: null,
                watermarkX: 0,
                watermarkY: 0,
                text: 'RENGEV',
                scale: 1,
                opacity: 1,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                offsetX: 0,
                offsetY: 0,
                isDarkText: false
            };
            
            textInput.value = 'RENGEV';
            scaleSlider.value = 1;
            scaleValue.textContent = '1.0';
            opacitySlider.value = 100;
            opacityValue.textContent = '100';
            
            uploadZone.classList.remove('hidden');
            canvasWrapper.classList.add('hidden');
            downloadBtn.disabled = true;
            resetBtn.disabled = true;
            fileInput.value = '';
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        const html = document.documentElement;

        function updateTheme(isDark) {
            if (isDark) {
                html.classList.add('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            } else {
                html.classList.remove('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            }
        }

        themeToggle.addEventListener('click', () => {
            const isDark = !html.classList.contains('dark');
            updateTheme(isDark);
        });

        colorToggle.addEventListener('click', () => {
            state.isDarkText = !state.isDarkText;
            requestRender();
        });
    </script>
</body>
</html>
